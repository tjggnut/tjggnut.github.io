---
title: 面向对象
date: 2018-08-04 10:30:46
tags:
---

## 面向对象概述

OOP是由对象组成的，每个对象包含了对用户公开的特定功能部分和隐藏的实现部分。

传统的结构化程序设计先考虑解决问题的算法，后考虑如何存放数据。而OOP将如何存放数据，再考虑操作数据的算法。比如我们在开发一个业务需求时，总是先根据业务形态总结出库表结构及相应bean的设计方案，而后才去设计业务流程。

### 类

类是对象的模板，由类构造对象的过程称为创建类的实例。

封装是将数据和行为组合在一个包中，并对使用者隐藏了实现方式。

对象中的数据称为**实例域**，操作数据的过程称为**方法**。

实现封装的关键是**绝对不能**让类中的方法直接地访问其他类的实例域。程序仅仅通过对象的方法与对象数据进行交互。

*问：bean中的getter和setter约等于暴露了私有实例域，那么意义何在？*

*答：见https://stackoverflow.com/questions/1568091/why-use-getters-and-setters-accessors*

类可以通过**继承**轻易的进行扩展。

### 对象

对象的三个主要特征：

- 行为：可以对对象进行哪些操作？
- 状态：对象如何响应操作
- 标识：如何区分对象？

对象的行为通过类中的方法来定义，状态通过对象中实例域的值来表征，每个对象都有一个唯一标识。对象的行为会改变状态，状态也会影响其所行为。

比如一个对一个订单进行送货，则会影响订单的状态为送货中，反过来该状态则导致订单中的货物不能再有所更改。

### 类之间的关系

- 依赖 (uses-a)
  一个类的方法操作另一个类的对象，称之为依赖。
- 聚合 (has-a)
  一个类的对象包含另一个类的对象，称之为聚合。
- 继承 (is-a)
  用于表示特殊与一般的关系。

## 使用类

Java语言使用**构造器**构造新实例。构造器的名字与类名相同。

```java
Date today = new Date();
System.out.println(today);//today.toString()
//Sat Aug 04 15:26:34 CST 2018
```

Java中，任何对象变量存储的值都是对存储在另外一个地方的一个对象的引用。语句

`Date today = new Date();`，表示构造了一个Date类型的对象，并且他的值是该对象的引用，然后将这个引用值存放到变量today中。

注：局部变量不会自动初始化为null，若未显示复制，则会有编译错误。

### 自定义类

Java中，最简单的类定义形式为：

```java
class ClassName{
    field1
    field2
    ···
    construct1
    construct2
    ···
    method1
    method2
    ···
}
```

下面我们来定义一个Employee类：

```java
public class Employee {
    //实例域
    private String name;
    private double salary;
    private Date hireDay;

    public Employee(String name, double salary, Date hireDay) {
        this.name = name;
        this.salary = salary;
        this.hireDay = hireDay;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getSalary() {
        return salary;
    }

    public void setSalary(double salary) {
        this.salary = salary;
    }

    public Date getHireDay() {
        return hireDay;
    }

    public void setHireDay(Date hireDay) {
        this.hireDay = hireDay;
    }
}
```

该类共有一个构造器和6个方法，并且均标记为public，意味着任何类的任何方法都可以调用这些方法。

另外还有三个实例域，被标记为private，确保只有Employee类本身访问这些实例域。

***？？？震惊？？？***

***一个方法可以访问所属类的所有对象的私有数据！***

```java
public boolean equals(Employee obj) {
    System.out.println(obj.name);
    return this.name.equals(obj.name);
}
```



### final实例域

将实例域声明为final，构建对象时必须初始化该域，且一经初始化后，则不允许再修改。如将Employee类中的name设置为final，则无法进行setName操作。

```java
public class Employee {
    //实例域
    private final String name;
    ...
}
```

final修饰符大多应用于***基本类型***域或***不可变***类型域(如String类型 或其域都不可变的类)。

也可以将final声明在类上，表示该类无法被继承，如String类：

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence
```

## 方法参数

***Java只有值传递！只有值传递！只有值传递！***

传递对象也只是传递该对象对应的变量的值而已，而这个值保存了该对象的引用。

通过swap(a,b)是无法交换a和b的内容的。

## 对象构造

#### 重载

当一个类的多个方法，有相同的名字、不同的参数时，便产生了重载。

（重载解析：编译器通过各个方法给出的参数类型与特定方法调用所使用的值类型进行匹配来挑选出相应的方法，如果找不到匹配的参数，则会产生编译错误。）

#### 默认域初始化

如果在构造器中没有显示地给域赋值，则会被默认赋值0、false、null。

#### 构造器

- 如果在编写类的时候没有提供任何构造器，则JVM？会自动给类添加一个默认无参构造器。（所以即使我们没有声明构造器，我们也能new ClassName()）
- 但是只要提供了有参构造器，又想要通过无参的方式实例化对象，则必须手动提供无参构造器。

初始化数据的具体步骤：

1. 所有数据域被初始化为默认值（0、false、null）
2. 按在类中的声明顺序执行域初始化语句 以及 初始化块。（不能直接优化为声明时就赋值吗?）
3. 执行构造器主题



注：在类加载时按声明顺序进行静态域的初始化。

### 包作用域

若一个类未被声明为public类，则只能在同一个包下访问这个类。

### 类设计准则

- 一定要保证数据私有
- 一定要对数据初始化
- 不要在类中过多的使用基本类型，而是使用其他类代替多个基本类型，易于理解。
- 不是所有的域都需要独立的访问器和更改器。
  (bean似乎是需要所有的，不然spring和mybatis怎么设置值呢，需进一步深究反射与自动注入。)
- 将职责过多的类进行分解。
- 类名和方法名要显示出他们的职责。
- 优先使用不可变的类。（更线程安全吧）























































































